takze u implementace predpokladame rozdeleni do dvou casti:
vypocetni metoda samotna, zda se, ze se vyskytuje ve dvou formach:
- hodnotova: vstupy jsou konkretni hodnoty, vystup je taky hodnota; pokud je tato operace relation-based,
  musi implementace specifikovat nejen, ke ktere relaci patri, ale i kterou z hodnot, jez relace
  propojuje, tato implementace pocita
- ValueSetova: vstupy jsou ValueSety, vystup je dedukce; dedukce specifikuje, ktereho vstupu se tyka, a
  message, ktera se ma tomu vstupu poslat, aby doslo k zakomponovani dedukce do stavu Gridu

wrapper, poskytujici interface pro nejaky typ MappingTypu; umi z MappingTypu dostat hodnotu (je-li
  jednoznacna) a ValueSet; poskytuje jednotnej interface, jehoz pomoci se Solver muze ptat
  na vystupy z implementacni metody
wrappery jsou taky dvou zakladnich typu, jeden pro hodnotove a jeden pro ValueSetove vypocetni metody;
  navenek poskytuji obe metody stejnej interface (vracejici dedukci)
uzivatel tedy nic o dvou typech implementaci/wrapperu nic nevi, z jeho pohledu existuji jen wrappery
  a jsou vsechny stejna pakaz, resp. odlisuji se tim:
    a) jakou relaci/operaci implementuji
    b) s jakymi MappingTypy si dovedou poradit?? -- neni to nahodou tak, ze tohle jsem opustil
        a pozaduju pro MappingTypy pouze to, aby umely vratit svuj stav jako ValueSet (tedy neco
        jako domenu, kde v principu asi potrebuju i pripustit moznost AnyValue) a pripadne
        pro zvyseni efektivity hledani umely rict Ano, uz vim, jaka je hodnota pro tento Key,
        a je to tahle??

dalsi problem je, ze zname wrappery musi nekde bydlet, aby si je solver mohl volat. Tady jsem na pude
  cireho vesteni, opravdu nevim, podle ceho bych mel zpusob implementace spravne vybirat. Volim tedy
  pro zacatek jednu arbitratily chosen moznost a casem treba vytvorim i nejake dalsi a pak udelam
  benchmarking nebo co ja vim.
zakladni otazka je, jestli wrappery maji existovat v runtime nebo jestli to maji byt jen compile-time
  abstrakce a zkompilovany kod ma uz mit v sobe primo volani vypocetnich metod. Zda se mi mirne
  snazsi implementovat dynamickou verzi, takze volim tuto.
na urovni namespace solver existuji templatovane promenne (staticke lokalni promenne templatovane metody)
  pro kazdy typ operace, resp. relace; promenna je typu std::vector<ImplWrapper>; kazda slusne vychovana
  implementace dedi nejakeho predka, jenz jako soucast sveho konstruktoru vola metodu, ktera ho do teto
  promenne zaregistruje; kazda slusne vychovana implementace ve svem cpp souboru z tohoto duvodu take
  vytvari na namespace urovni statickou promennou, obsahujici jednu instanci sve implementace, cimz
  dojde k vyvolani toho konstruktoru

jako alternativni moznosti se nabizi full compile time scenar, v nemz nejak iteruju pres zname
  implementace uz pri kompilaci
dalsi moznost je nepotrebovat instance Implementaci, jezto implementacni metoda i metoda wrapperu,
  pres niz se k implementacni metode pristupuje, mohou byt static
nejvhodnejsi zpusob, jak implementace v techto dvou scenarich registrovat k pouziti, neni promyslen

takze wrapper, jak nastinen vyse, je ve skutecnosti staticka trida templatovana idckem relace, kterou
  wrapuje, s dvema responsibilitami:
    - spravuje "pole" implementaci, ktere se prihlasi k tomu, ze implementuji prislusnou relaci
    - poskytuje statickou metodu, jejiz pomoci uzivatel muze vyuzit "sluzeb" prihlasenych implementaci

wrappery pro InitStep a pro Constraint se znacne lisi:
  - InitStepovy wrapper ma navic parametr input
  - Constraintovy wrapper pri bootstrapu taky nejak meni obsah Gridu: rozklad Constraintu do Operations
      vyzaduje pomocne Mappingy, ty musi nejak vzniknout a byt naplneny inicializacnimi hodnotami

now rozdil solver vs grid_builder. Vlastne se zda, ze rozdil neni, az na to, ze grid_builder
  potrebuje input vstupni parametr a solver ne. Dalo by se tedy uvazovat o tom, ze grid_building
  ma dve faze, prvni kopiruje data z inputu do zpocatku prazdneho gridu (interpretujic je pritom,
  when needed), druha faze pak dela solving uplne stejne jako solver, pouze je vybavena constrainty
  s jinymi vlastnostmi nez solver. Ano, to je skvele. GridBuilder ma totiz pouze jeden vstupni
  parametr, a to je prave ten input; GridBuilder vytvori prazdny Grid, nakopiruje do nej data
  z inputu a s takto vzniklym Gridem zavola solvovaci metodu, instancializovanou s vhodnymi Stepy.
  I like it. (Viz nize, actually after some thought I don't like it anymore at all).

cili z predchoziho plyne, ze potrebuju nejakou classu, ktera je templatovana na operation_ids a ma
  metodu s jednim parametrem typu Grid. Tato classa prochazi operace, ktere ma brat v potaz, jejich
  implementace, ktere ma k dispozici, a hleda pomoci tech implementaci nejake dedukce. A ted chovani
  tyhle tridy nabizi ruzne moznosti: v jakym poradi operace prochazet, ???

predpokladejme tedy interface DeductionEngine

template<typename... Operations>
class DeductionEngine {
  public:
    std::vector<Deduction> deduce( const Grid& grid );
};

jiny pohled: rozdil mezi solverem a grid_builderem je zcela zasadni. faze, jak jsem je popsal vyse,
  nejsou oddelene, resp. neni to tak, ze napred jde udelat komplet faze 1 a pak teprve zacit s fazi 2.
  prekopirovat data neni tak jednoduche, jak by to mohlo znit (Centers). pri buildeni se data do Gridu
  pridavaji, zatimco pri solveni se mazou. vsechny uvahy pri buildeni jsou hodnotove, tj. na vstupu
  pracuji se znamymi hodnotami, nikoli s mnozinami potencialne moznych hodnot. kroky se delaji 
  v predepsanem poradi postupne, nesplnenost predpokladu (znalost prislusnych hodnot) je fatal error.
  Result: ackoli existuji jiste podobnosti mezi buildenim gridu a solvenim, rozdilu je rovnez velmi
  mnoho a jsou dost zasadni; rozhodne nema cenu mit jeden specializovany objekt, ktery bude umet
  delat oboji. Neni nutne zcela rezignovat na moznost, ze by nektere casti kodu pouzivaly obe operace,
  ale znacna cast funkcionality ma byt implementovana pro kazdou operaci zvlast.
